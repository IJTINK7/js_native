// Event loop

// ## Архитектура браузера:
// 1) **User Interface (UI)** - Часть браузера, с которой взаимодействует пользователь
//
// 2) **Browser Engine (Браузерный движок)** - Соединительная часть браузера между UI и механизмом рендеринга. На основе входных данных от пользователя движок взаимодействует с механизмом рендеринга и управляет им.
//
// 3) **Rendering engine (Движок рендера (Webkit(Chrome), Gecko (Firefox)))** - Самая важная часть браузера, благодаря которому получаем страницы, приложения. Движок обрабатывает написанный код, строит DOM, определяется расположение элементов и т.д.
//
// **Networking** - всё, что связано с сетью (история сайтов, доменные имена, HTTP, TCP).
//
// **JS Interpreter** - движок JS, именно он используется в браузере и обрабатывает JS код (V8), он предоставляет heap(кучу, область памяти с объектами, массивами и т.п.), callstack, предоставляет работу с памятью (в т.ч. сборка мусора)компиляция JS в машинный код.
//
// **UI Backend** - внутренняя часть, подкапотная логика
//
// **Data Persistence** - хранилище данных, локальная база данных (local storage, session storage, cookie, вкладки, файловая система).
//
// ## **Event loop - отдельный механизм, который позволяет использовать неблокирующую модель вводаи вывода и не является частью JS (именно для этого используется V8). Здесь же про Call stack.**
//
// Event loop в браузере и Node.js - абсолютно разные, хоть и решают одну задачу
//
// ## Call stack - стек вызовов, за который отвечат движок JS
//
// Call stack складывает фуекции в определённом порядке, в котором они должны быть вызваны
//
// ## Асинхронные примеры:
//
// Здесь важно уяснить про **очередь задач(Task queue), в которую** попадает весь асинхронный код! Функция setTimeout как раз и является такой. Именно поэтому сразув консоли увидим “start”, “end”, “timeout”.
//
// Итак, все функции **из стека**(синххронный код) выполняются в первую очередь, а только потом будет выполняться **очередь задач.**
//
// ## Как задачи попадают в очередь задач? + Задача с setTimeout()
//
// За очередь отвечает Event loop, а за call stack отвечают движки JS:
//
// Так как же **очередь задач** (предоставляемая Event loop) **и call stack**(предоставляемый движком JS) общаются между собой?
//
// **У каждого браузера есть Web API** (предоставляет таймауты, события, отправка запросов и т.д. и относится к браузеру).
//
// **Разбираемся:**
//
// Итак, функция setTimeout попадает в call stack
//
// После этого он регистрируется в Web API и вот на этом этапе запускается таймер (3,2,1).
//
// После того как таймер иссяк, мы отправляем наш колбэк в очередь задач
//
// И после того как call stack очистился, настало время взять задачу из очереди.
//
//     Всё!